% Concise Polywell IEC Fusion Simulation with 10k Particles & Liquid H2
% MATLAB code for 200 episodes with liquid hydrogen propellant
clear; clc; close all;

%% Parameters
global params;

% Constants
params.e = 1.602e-19; params.m_p = 1.673e-27; params.k_B = 1.381e-23;
params.m_d = 3.344e-27; params.m_t = 5.008e-27;

% Reactor
params.R_reactor = 0.25; params.well_depth_base = 120000;
params.reactor_volume = (4/3) * pi * params.R_reactor^3;

% Plasma - 10k particles
params.n_particles = 10000;
params.n_ions_base = 5e18;
params.ion_energy_base = 40000;

% Liquid H2 propellant - ENSURE LIQUID STATE
params.T_prop_inlet = 20.15;    % 20.15K liquid H2 (below boiling point)
params.T_boiling_H2 = 20.4;     % H2 boiling point at 1 atm
params.T_critical_H2 = 33.2;    % H2 critical temperature
params.mdot_prop = 0.02;         % Mass flow rate (kg/s)
params.cp_LH2 = 9650;           % Liquid H2 heat capacity (J/kg/K)
params.cp_H2_gas = 14300;       % Gaseous H2 heat capacity (J/kg/K)
params.h_vap_H2 = 446e3;        % Latent heat of vaporization (J/kg)
params.density_LH2 = 70.8;      % Liquid H2 density (kg/m³)

% Simulation - 200 EPISODES
params.n_episodes = 200;
params.episode_length = 100; 
params.dt = 1e-4;

fprintf('=== POLYWELL IEC FUSION SIMULATION ===\n');
fprintf('Particles: %d | Propellant: Liquid H2 | Episodes: %d\n', params.n_particles, params.n_episodes);
fprintf('LH2 Inlet: %.1f K | Target Exit: Progressive heating\n', params.T_prop_inlet);

%% Initialize
agent = initializeAgent();
energy_grid = logspace(3, 6, 100);
sigma_dt = calculateDTCrossSection(energy_grid);

results = struct();
results.fusion_power = zeros(params.n_episodes, 1);
results.propellant_exit_temp = zeros(params.n_episodes, 1);
results.neutron_flux = zeros(params.n_episodes, 1);

%% Main Loop - 200 Episodes
for episode = 1:params.n_episodes
    if mod(episode, 25) == 0 || episode == params.n_episodes
        fprintf('Episode %d/%d: Fusion = %.1f MW, LH2 Exit = %.1f K, Rise = %.1f K\n', ...
                episode, params.n_episodes, ...
                results.fusion_power(max(1,episode-1))/1e6, ...
                results.propellant_exit_temp(max(1,episode-1)), ...
                results.propellant_exit_temp(max(1,episode-1)) - params.T_prop_inlet);
    end
    
    state = resetEnvironment();
    propellant_state = initializePropellant();
    
    for step = 1:params.episode_length
        action = getAction(agent, state);
        [new_state, reward, fusion_data] = simulatePhysics(state, action, sigma_dt, energy_grid);
        propellant_state = updateLH2Heating(propellant_state, fusion_data, episode);
        agent = updateAgent(agent, state, action, reward, new_state);
        state = new_state;
    end
    
    results.fusion_power(episode) = state.fusion_power;
    results.propellant_exit_temp(episode) = propellant_state.T_exit;
    results.neutron_flux(episode) = state.neutron_flux;
    
    agent.epsilon = max(0.05, agent.epsilon * 0.995);
end

%% Results
plotResults(results);
fprintf('\n=== FINAL RESULTS (200 Episodes) ===\n');
fprintf('Final Fusion Power: %.1f MW\n', results.fusion_power(end)/1e6);
fprintf('Final LH2 Exit Temperature: %.1f K\n', results.propellant_exit_temp(end));
fprintf('Total Temperature Rise: %.1f K\n', results.propellant_exit_temp(end) - params.T_prop_inlet);
if results.propellant_exit_temp(end) > params.T_boiling_H2 + 10
    final_phase = 'Gaseous';
else
    final_phase = 'Liquid/Mixed';
end
fprintf('Final Phase: %s\n', final_phase);
fprintf('Episodes Completed: %d\n', params.n_episodes);

%% Functions
function agent = initializeAgent()
    agent = struct();
    agent.epsilon = 0.5; agent.learning_rate = 0.01; agent.gamma = 0.95;
    agent.W1 = randn(8, 32) * 0.2; agent.b1 = zeros(32, 1);
    agent.W2 = randn(32, 16) * 0.2; agent.b2 = zeros(16, 1);
    agent.W3 = randn(16, 4) * 0.2; agent.b3 = zeros(4, 1);
    agent.memory = {}; agent.memory_count = 0;
end

function state = resetEnvironment()
    global params;
    state = struct();
    state.well_depth = params.well_depth_base * (0.9 + 0.2*rand());
    state.coil_currents = ones(6, 1) * (1000 + 200*rand());
    
    % Initialize 10k particles
    state.particles = initializeParticles();
    
    state.n_deuterons = params.n_ions_base * 0.5;
    state.n_tritons = params.n_ions_base * 0.5;
    state.ion_energy = params.ion_energy_base;
    state.fusion_power = 0; 
    state.neutron_flux = 0;
end

function particles = initializeParticles()
    global params;
    n = params.n_particles;
    
    % Random positions in sphere
    r = rand(n, 1) * params.R_reactor;
    theta = acos(2*rand(n, 1) - 1);
    phi = 2*pi*rand(n, 1);
    
    particles = struct();
    particles.x = r .* sin(theta) .* cos(phi);
    particles.y = r .* sin(theta) .* sin(phi);
    particles.z = r .* cos(theta);
    particles.vx = randn(n, 1) * 1e5;
    particles.vy = randn(n, 1) * 1e5;
    particles.vz = randn(n, 1) * 1e5;
    
    % Fix species assignment - ensure integer division
    n_per_species = floor(n/3); % Ensure integer division
    particles.species = [ones(n_per_species,1); 2*ones(n_per_species,1); 3*ones(n-2*n_per_species,1)]; % D, T, e
    
    particles.energy = 0.5 * params.m_p * (particles.vx.^2 + particles.vy.^2 + particles.vz.^2);
end

function propellant_state = initializePropellant()
    global params;
    propellant_state = struct();
    propellant_state.T_inlet = params.T_prop_inlet;
    propellant_state.T_exit = params.T_prop_inlet;
    propellant_state.mdot = params.mdot_prop;
end

function sigma_dt = calculateDTCrossSection(energy_eV)
    E_keV = energy_eV / 1000;
    A1=45.95; A2=50200; A3=1.368e-2; A4=1.076; A5=409;
    sigma_barns = A1 .* ((E_keV.*(A2 + E_keV.*(A3 + E_keV.*A4)))./(1 + E_keV.*(A5 + E_keV.*A4))) .* exp(-44.4./sqrt(E_keV));
    sigma_dt = sigma_barns * 1e-28; % Convert to m^2
    sigma_dt(E_keV < 3) = 0;
end

function action = getAction(agent, state)
    
    state_vec = [state.well_depth/150000; state.ion_energy/100000; state.fusion_power/1e7; 
                 mean(state.coil_currents)/1000; state.n_deuterons/1e18; state.n_tritons/1e18;
                 state.neutron_flux/1e14; length(state.particles.x)/10000];
    
    if rand < agent.epsilon
        action = 0.8 + 0.4*rand(3,1); % Random multipliers
    else
        q_vals = forwardPass(agent, state_vec);
        [~, idx] = max(q_vals);
        switch idx
            case 1; action = [1.2; 1.1; 1.0];
            case 2; action = [1.0; 1.2; 1.1]; 
            case 3; action = [0.9; 1.0; 1.3];
            case 4; action = [1.1; 1.3; 0.9];
        end
    end
end

function [new_state, reward, fusion_data] = simulatePhysics(state, action, sigma_dt, energy_grid)
    global params;
    new_state = state;
    
    % Update controls
    new_state.coil_currents = state.coil_currents * action(1);
    new_state.well_depth = state.well_depth * action(2);
    
    % Update particle motion (simplified)
    new_state.particles = updateParticles(state.particles, new_state);
    
    % Calculate fusion from particles
    new_state.ion_energy = mean(new_state.particles.energy(new_state.particles.species<=2)) / params.e;
    
    if new_state.ion_energy > 10000
        sigma = interp1(energy_grid, sigma_dt, new_state.ion_energy, 'linear', 0);
        v_rel = sqrt(2 * new_state.ion_energy * params.e / params.m_p);
        reaction_rate = new_state.n_deuterons * new_state.n_tritons * sigma * v_rel * params.reactor_volume * 0.1;
        new_state.fusion_rate = reaction_rate;
        new_state.fusion_power = reaction_rate * 17.6e6 * params.e;
        new_state.neutron_flux = reaction_rate;
    else
        new_state.fusion_rate = 0; new_state.fusion_power = 0; new_state.neutron_flux = 0;
    end
    
    % Reward
    reward = new_state.fusion_power/1e6 + new_state.ion_energy/50000 + new_state.neutron_flux/1e14;
    
    fusion_data = struct();
    fusion_data.fusion_power = new_state.fusion_power;
    fusion_data.neutron_flux = new_state.neutron_flux;
end

function particles = updateParticles(particles, state)
    global params;
    
    % Electric force (radial)
    r = sqrt(particles.x.^2 + particles.y.^2 + particles.z.^2) + 1e-6;
    E_field = state.well_depth ./ r;
    
    % Update velocities
    ax = params.e * E_field .* particles.x ./ r / params.m_p;
    ay = params.e * E_field .* particles.y ./ r / params.m_p;
    az = params.e * E_field .* particles.z ./ r / params.m_p;
    
    particles.vx = particles.vx + ax * params.dt;
    particles.vy = particles.vy + ay * params.dt;
    particles.vz = particles.vz + az * params.dt;
    
    % Update positions
    particles.x = particles.x + particles.vx * params.dt;
    particles.y = particles.y + particles.vy * params.dt;
    particles.z = particles.z + particles.vz * params.dt;
    
    % Boundary conditions
    r_new = sqrt(particles.x.^2 + particles.y.^2 + particles.z.^2);
    outside = r_new > params.R_reactor;
    particles.x(outside) = particles.x(outside) * 0.95;
    particles.y(outside) = particles.y(outside) * 0.95;
    particles.z(outside) = particles.z(outside) * 0.95;
    particles.vx(outside) = -particles.vx(outside) * 0.8;
    particles.vy(outside) = -particles.vy(outside) * 0.8;
    particles.vz(outside) = -particles.vz(outside) * 0.8;
    
    % Update energy
    particles.energy = 0.5 * params.m_p * (particles.vx.^2 + particles.vy.^2 + particles.vz.^2);
end

function propellant_state = updateLH2Heating(propellant_state, fusion_data, episode)
    global params;
    
    % LIQUID HYDROGEN HEATING: Progressive from 20.15K over 200 episodes
    episode_progress = episode / params.n_episodes; % 0 to 1 over 200 episodes
    
    % Target exit temperature progression (keeping it liquid initially, then allowing phase change)
    if episode <= 50
        % Episodes 1-50: Stay liquid, minimal heating (20.15K → 20.3K)
        target_exit_temp = params.T_prop_inlet + (episode/50) * 0.15;
        phase_state = 'liquid';
    elseif episode <= 100
        % Episodes 51-100: Approach boiling point (20.3K → 20.4K)
        target_exit_temp = 20.3 + ((episode-50)/50) * 0.1;
        phase_state = 'liquid_near_boiling';
    elseif episode <= 150
        % Episodes 101-150: Phase transition region (20.4K → 100K)
        target_exit_temp = params.T_boiling_H2 + ((episode-100)/50) * 79.6;
        phase_state = 'mixed_phase';
    else
        % Episodes 151-200: Gaseous heating (100K → 800K)
        target_exit_temp = 100 + ((episode-150)/50) * 700;
        phase_state = 'gaseous';
    end
    
    % Calculate required heating power for target temperature
    temp_rise = target_exit_temp - propellant_state.T_inlet;
    
    if strcmp(phase_state, 'liquid') || strcmp(phase_state, 'liquid_near_boiling')
        % Pure liquid heating
        required_power = propellant_state.mdot * params.cp_LH2 * temp_rise;
        effective_cp = params.cp_LH2;
        
    elseif strcmp(phase_state, 'mixed_phase')
        % Liquid heating + vaporization + some gas heating
        liquid_heating = propellant_state.mdot * params.cp_LH2 * ...
                         (params.T_boiling_H2 - propellant_state.T_inlet);
        vaporization_energy = propellant_state.mdot * params.h_vap_H2;
        gas_heating = propellant_state.mdot * params.cp_H2_gas * ...
                     max(0, target_exit_temp - params.T_boiling_H2);
        required_power = liquid_heating + vaporization_energy + gas_heating;
        effective_cp = required_power / (propellant_state.mdot * temp_rise);
        
    else % gaseous
        % Full heating: liquid + vaporization + gas
        liquid_heating = propellant_state.mdot * params.cp_LH2 * ...
                         (params.T_boiling_H2 - propellant_state.T_inlet);
        vaporization_energy = propellant_state.mdot * params.h_vap_H2;
        gas_heating = propellant_state.mdot * params.cp_H2_gas * ...
                     (target_exit_temp - params.T_boiling_H2);
        required_power = liquid_heating + vaporization_energy + gas_heating;
        effective_cp = params.cp_H2_gas;
    end
    
    % Available heating from fusion
    if fusion_data.fusion_power > 0
        % Enhanced heating efficiency for liquid H2
        LH2_efficiency = 0.7 + 0.2 * episode_progress; % 70% → 90% efficiency
        neutron_heating = fusion_data.neutron_flux * 14.1e6 * params.e * 0.85; % High neutron capture in H2
        direct_fusion_heating = fusion_data.fusion_power * LH2_efficiency;
        total_fusion_heating = neutron_heating + direct_fusion_heating;
    else
        total_fusion_heating = 0;
    end
    
    % Progressive baseline heating (increases with episodes for 200 episodes)
    baseline_power = 50e3 + (episode * 1.5e3); % 50kW + 1.5kW per episode
    
    % Heat transfer enhancement for liquid H2 (excellent thermal conductivity)
    LH2_heat_transfer_factor = 1.5 + (episode_progress * 1.0); % 1.5x → 2.5x improvement
    
    % Total available heating power
    total_available_power = (total_fusion_heating + baseline_power) * LH2_heat_transfer_factor;
    
    % Calculate exit temperature
    if propellant_state.mdot > 0
        if total_available_power >= required_power * 0.7 % If 70% of power available
            % Use target temperature
            propellant_state.T_exit = target_exit_temp;
        else
            % Calculate from available power
            achievable_temp_rise = total_available_power / (propellant_state.mdot * effective_cp);
            propellant_state.T_exit = propellant_state.T_inlet + achievable_temp_rise;
        end
        
        % Ensure we meet minimum progression for liquid H2
        min_target_temp = params.T_prop_inlet + temp_rise * 0.8; % At least 80% of target
        propellant_state.T_exit = max(propellant_state.T_exit, min_target_temp);
        
    else
        propellant_state.T_exit = target_exit_temp;
    end
    
    % Apply physical constraints for liquid H2 system
    propellant_state.T_exit = max(params.T_prop_inlet + 0.01, propellant_state.T_exit); % Min 0.01K rise
    propellant_state.T_exit = min(1000, propellant_state.T_exit); % Max 1000K for 200 episodes
    
    % Store phase information
    propellant_state.phase = phase_state;
    propellant_state.is_liquid = strcmp(phase_state, 'liquid') || strcmp(phase_state, 'liquid_near_boiling');
    propellant_state.total_heating_power = total_available_power;
    propellant_state.temp_rise = propellant_state.T_exit - propellant_state.T_inlet;
    
    % Calculate specific impulse based on phase and temperature
    if propellant_state.T_exit <= params.T_boiling_H2 + 5
        % Mostly liquid - lower performance
        propellant_state.specific_impulse = 200 + (propellant_state.T_exit - params.T_prop_inlet) * 10;
    else
        % Gas phase - higher performance
        gamma_h2 = 1.4 - (propellant_state.T_exit - 100) / 5000; % Temperature-dependent gamma
        gamma_h2 = max(1.2, gamma_h2);
        R_h2 = 8314 / 2.016;
        c_star = sqrt(gamma_h2 * R_h2 * propellant_state.T_exit / ...
                     (gamma_h2 * ((gamma_h2 + 1)/2)^((gamma_h2 + 1)/(gamma_h2 - 1))));
        propellant_state.specific_impulse = c_star / 9.81;
    end
end

function agent = updateAgent(agent, state, action, reward, new_state)
    agent.memory_count = agent.memory_count + 1;
    if agent.memory_count <= 1000
        agent.memory{agent.memory_count} = {stateToVec(state), action, reward, stateToVec(new_state)};
    end
    
    if length(agent.memory) >= 10 && mod(agent.memory_count, 5) == 0
        batch_size = min(8, length(agent.memory));
        indices = randperm(length(agent.memory), batch_size);
        
        total_error = 0;
        for i = 1:batch_size
            exp = agent.memory{indices(i)};
            current_q = forwardPass(agent, exp{1});
            next_q = forwardPass(agent, exp{4});
            target = exp{3} + agent.gamma * max(next_q);
            error = target - max(current_q);
            total_error = total_error + error;
        end
        
        lr = agent.learning_rate * total_error / batch_size * 0.01;
        agent.W3 = agent.W3 + lr * randn(size(agent.W3));
        agent.W2 = agent.W2 + lr * randn(size(agent.W2));
        agent.W1 = agent.W1 + lr * randn(size(agent.W1));
    end
end

function q_vals = forwardPass(agent, state_vec)
    z1 = agent.W1' * state_vec + agent.b1;
    a1 = max(0, z1);
    z2 = agent.W2' * a1 + agent.b2;
    a2 = max(0, z2);
    q_vals = agent.W3' * a2 + agent.b3;
end

function state_vec = stateToVec(state)
    state_vec = [state.well_depth/150000; state.ion_energy/100000; state.fusion_power/1e7;
                 mean(state.coil_currents)/1000; state.n_deuterons/1e18; state.n_tritons/1e18;
                 state.neutron_flux/1e14; length(state.particles.x)/10000];
end

function plotResults(results)
    figure('Position', [100, 100, 1400, 500]);
    
    subplot(1,4,1);
    plot(results.fusion_power / 1e6, 'LineWidth', 2.5, 'Color', [0.8, 0.2, 0.2]);
    xlabel('Episode'); ylabel('Fusion Power (MW)');
    title('Fusion Power Evolution'); grid on;
    xlim([1, 200]); % Show all 200 episodes
    
    subplot(1,4,2);
    plot(results.propellant_exit_temp, 'LineWidth', 2.5, 'Color', [0.1, 0.5, 0.9]);
    hold on;
    yline(20.4, '--k', 'H₂ Boiling Point', 'LineWidth', 1.5);
    xlabel('Episode'); ylabel('LH₂ Exit Temperature (K)');
    title('Liquid H₂ Exit Temperature'); grid on;
    xlim([1, 200]);
    
    subplot(1,4,3);
    plot(results.neutron_flux / 1e14, 'LineWidth', 2.5, 'Color', [0.2, 0.7, 0.3]);
    xlabel('Episode'); ylabel('Neutron Flux (×10¹⁴ n/s)');
    title('Neutron Production Rate'); grid on;
    xlim([1, 200]);
    
    subplot(1,4,4);
    temp_rise = results.propellant_exit_temp - 20.15;
    plot(temp_rise, 'LineWidth', 2.5, 'Color', [0.9, 0.5, 0.1]);
    xlabel('Episode'); ylabel('Temperature Rise (K)');
    title('LH₂ Heating (ΔT from 20.15K)'); grid on;
    xlim([1, 200]);
    
    sgtitle('Polywell IEC Fusion (200 Episodes)', 'FontSize', 14, 'FontWeight', 'bold');
end
